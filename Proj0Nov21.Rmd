---
title: "ProjectZero_Nov2021"
output: html_document
---

9th November 2021

##Libraries

```{r}
library("ggplot2")
library("ggpubr")
library("FSA")
library("stringr")
library("dplyr")
```


## Project Notes 

This project is concerned with looking at evolutionary signatures of selection on immune-associated genes, both canonical and candidate. All immune genes (canon/noncanon) are based on orthologs from *Apis mellifera* (Amel_HAv3.1, NCBI genome).

Two types of analyses have been previously ran using PAML's module, codeML, using gene product codon alignments consisting of 11 bee species, including *Apis mellifera*. Gene sets are divided into "immunity" and "random", with immunity consisting of "canon" and "non-canon". All alignments consist of 1-1 single-copy orthologs present in all 11 species. Those that did not include all species were dropped.

Evolutionary rate of each gene product was estimated using a codeml run that considers the whole gene product across the given phylogeny as a whole. It is not expected to get dN/dS ratio (omega) values anywhere near 1 (positive selection) using this method as site-specific signals of selection will be likely lost as the ratio is averaged along the length of the product. Instead, this is expected to offer a relative scale of evolutionary rate.

The main analysis consisted of branch-site specific analyses of selection wherein the phylogenetic tree was designated a target, splitting the tree into foreground and background. CodeML then estimates omega value for foreground branches relative to background. For the purposes of this project, each of the designations correspond with the origin or elaboration of social living, to assess if and how these changes in lifestyle affected selection on immune and candidate immune genes in the bees, relative to other genes (the "random" set, which encompass all orthologs that could be made from all proteins in Apis mellifera using the ortholog bash script, OrthoScript [imaginitively named]).

A list of all of the designations and the input newick formats is available in Genome_Misc/tree_designations.txt. I.e.

```{r}
cat(readLines('Genome_Misc/tree_designations.txt', n=2), sep="\n")
```


In the null version of this test, omega ratios on the foreground branches are fixed at 1, with the alternative version starting with omega estimates above 1 (a direct test of positive selection). Each model results in a global maximum log likelihoood score which can then be compared using a LRT.

LRT = (lnLAlt - lnLNull)*2

LRT scores can then be compared to a chi-square distribution with 1 degree of freedom to assess significance. LRT scores above 3.84 are considered significant. 

P-values will be adjusted during this analysis to correct for multiple testing using the Benjamini-Hochburg procedure.

##Setting the Verse

In order to annotate the data with class of gene, description of gene (as it is described in Apis mellifera), etc. we first need a "dataverse" of Amel_HAv3.1.

verseSet.R reads in the relevant information from the Genome_Misc and ImmResources folders.

```{r}
source("Scripts/verseSet.R", local = knitr::knit_global())
```

The verse : a table with each gene tested, it's omega value, GC content, length, number of codons, and immune / non-immune function.

```{r}
head(verse)
```

###Dataset

Read in the results files for each of the 11 origins / elaborations / combinations of branch site analyses. 

Each lnLResults.txt file consists of the name of the gene, the log likelihood score of the null and alternative branch-site models (lnL_Null / lnL_Alt) and the results of the likelihood ratio test ran between them (LRT).

These raw data files look like this.

```{r}
cat(readLines("input/codemlFull/AllComplex.lnLResults.txt", n=5), sep = '\n')
```

###Adding annotations

dataRead.R will read in the results file, collate them into one source and annotate each gene with gene class, immune function, and alignment / gene information.

```{r}
source("Scripts/dataRead.R", local = knitr::knit_global())
```

```{r}
head(data[[2]], n = 40)
```

###Remove Non-coding Elements

There are some codon alignments in the midst that were based on non-coding transcripts. I will be reomving these from the analysis.

```{r}
imm.nc <- read.table("Genome_Misc/ImmRun_noncoding_list.txt")
gene<-strsplit(as.character(imm.nc$V1),".",fixed = T)
imm.nc$Gene<-sapply(gene,"[",1)
imm.nc$V1 <- NULL
imm.nc$Gene <- as.factor(imm.nc$Gene)
head(imm.nc)
```

```{r}
for (i in 1:length(data)){
  data[[i]]$Gene <- as.factor(data[[i]]$Gene)
  data[[i]] <- data[[i]][!data[[i]]$Gene %in% imm.nc$Gene,]
}


data[[3]][grep("LOC113218526", data[[3]]$Gene),]
```


###Tests of significance

SigTest.R uses the LRT scores and a Chi square distribution (one-tailed, one degree of freedom) to produce pvalues. Pvalues below 0.05 are considered significant (before correction for multiple testing).

To correct for multiple testing, I'll be using the Benjamini-Hochburg procedure.

```{r}
source("Scripts/SigTests.R", local = knitr::knit_global())
```

```{r}
head(data[[3]])
```

How many are still considered significant ? 

```{r}
data.df <- bind_rows(data)
data.df$SocOrigin <- as.factor(data.df$SocOrigin)
data.sig.df <- filter(data.df, adj_pvalue < 0.05)
summary(data.sig.df$SocOrigin)
```

###Check for unannotated genes

```{r}
noclass <- data.df$Gene[is.na(data.df$Class)]
nofunction <- data.df$Gene[is.na(data.df$Function)]

unique(noclass == nofunction)
```


If these genes don't have the alignment annotations it means they were removed from the dN.dS or GC content analyses for a reason (ie too small, alignment wrong, etc). And so I will remove them from this analysis.

```{r}
data.df <- data.df[!data.df$Gene %in% noclass,]
data.df[data.df$Gene %in% noclass,]
```

Has this made any change ? 

```{r}
data.sig.df <- filter(data.df, adj_pvalue < 0.05)
summary(data.sig.df$SocOrigin)
```

###Write Up

```{r}
write.table(data.df, "output/CodeML_Results_All_Nov21.tsv", quote = F, row.names = F, sep = "\t")
```

## PSGs: Immunity, Sociality ....

###Pearson's ChiSq with Simulated Pvalues

Using contigency tables, I will also be running ChiSq tests of significance comparing immune classes / functions to background genes. As in some of these cases the sample frequencies are heavily imbalanced (i.e 5 canonical immune genes under selection versus ~6000 random genes not under selection), I will be simulating the pvalue by Monte Carlo simulation (x10000). 

First I'd like to just see how many are under selection across all the branch tests

```{r}
work3 <- data.df
work3$PSG <- ifelse(work3$adj_pvalue < 0.05, "Under Selection", "Not Under Selection")

table(work3$BranchTested, work3$PSG)
```


```{r}
table(work3$SocOrigin, work3$PSG)
```

```{r}
socs <- as.character(unique(work3$SocOrigin))

undersel <- data.frame(BranchTested = character(),
                       AllGenes = numeric(),
                       AllCanon = numeric(),
                       Receptor = numeric(),
                       Signalling = numeric(),
                       Effector = numeric(),
                       NonCanon = numeric(),
                       Background = numeric()
                       )

for (i in 1:length(socs)){
  run <- socs[i]
  x <- work3[work3$SocOrigin == paste(socs[i]) & work3$PSG == "Under Selection",]
  allgenes <- nrow(x)
  can <- nrow(x[x$Class == "Canon Immune" ,])
  rec <- nrow(x[x$Function == "Receptor", ])
  sig <- nrow(x[x$Function == "Signalling", ])
  eff <- nrow(x[x$Function == "Effector", ])
  non <- nrow(x[x$Class == "Non-Canon", ])
  back <- nrow(x[x$Class == "Background", ])
  out <- cbind(run, allgenes, can, rec, sig, eff, non, back)
  undersel[i,] <- out
}


undersel
```
```{r}
undersel$SocialScale[undersel$BranchTested %in% elaboration] <- "Elaboration of Sociality"
undersel$SocialScale[undersel$BranchTested %in% origin] <- "Origin of Sociality"
undersel$SocialScale[undersel$BranchTested %in% solitary] <- "Solitary"
```


Let's have a look at these

```{r}
for (i in 2:(ncol(undersel)-1)){
  undersel[,i] <- as.numeric(undersel[,i])
}

ggplot(data = undersel, aes(x=BranchTested, y = AllGenes, fill = SocialScale)) +
  geom_bar(colour="black", stat="identity")
```
Meli is just ridiculous.

Anyhoo.


```{r}
source("Scripts/chi_Nov21.R", local = knitr::knit_global())
```

```{r}
chi.res
```

```{r}
chi.res$can.adj.pvalue <- p.adjust(chi.res$p.value...5, method = "BH")
chi.res$non.adj.pvalue <- p.adjust(chi.res$p.value...9, method = "BH")

chi.res <- chi.res[,c(1:5,10,6:9,11)]
head(chi.res)
```

There's only the AllSol Canon versus Background hit that's significant, and not after correction for multiple testing.

```{r}
a <- chi.res[,1:2]
a$Class <- paste("Canon")
names(a)[1:2]<-c("Branch", "Prop")
b <- chi.res[,c(1,3)]
b$Class <- paste("Background")
names(b)[1:2]<-c("Branch", "Prop")
c <- chi.res[,c(1,7)]
c$Class <- paste("Non-Canon")
names(c)[1:2]<-c("Branch", "Prop")
chi.plot <- rbind(a,b,c)

chi.plot$BranchTest[chi.plot$Branch %in% elaboration] <- "Elaboration of Sociality"
chi.plot$BranchTest[chi.plot$Branch %in% origin] <- "Origin of Sociality"
chi.plot$BranchTest[chi.plot$Branch %in% solitary] <- "Solitary"



ggplot(chi.plot, aes(x = Branch, y = Prop, fill = Branch)) +
  geom_bar(stat = "identity") +
  facet_wrap(~Class) +
  coord_flip()
```



Write a table that requires editing manually 

```{r}
write.table(chi.res, "output/ChiSq_Raw.tsv", col.names = F, row.names = F, quote = F, sep = "\t")
```

###ChiSq: Gene Class vs Sociality

Looking if there is difference in number of genes under selection across the three different types of branches tested as foreground across the three classes. 


For canon genes under selection

```{r}
branches <- unique(data.df$BranchTested)
branches
```


```{r}
sel <- vector(length = 3)
for (i in 1:length(branches)){
  sel[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Canon Immune"
                           & data.df$PSG == 1]))
}

no.sel <- vector(length = 3)
for (i in 1:length(branches)){
  no.sel[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Canon Immune"
                           & data.df$PSG == 0]))
}

prop.test(sel, no.sel)
```

```{r}
prop.trend.test(sel, no.sel)
```

```{r}
sel2 <- vector(length = 3)
for (i in 1:length(branches)){
  sel2[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Non-Canon"
                           & data.df$PSG == 1]))
}

no.sel2 <- vector(length = 3)
for (i in 1:length(branches)){
  no.sel2[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Non-Canon"]))
}


prop.test(sel2, no.sel2)
```

```{r}
prop.trend.test(sel2,no.sel2)
```

```{r}
sel3 <- vector(length = 3)
for (i in 1:length(branches)){
  sel3[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Background"
                           & data.df$PSG == 1]))
}

no.sel3 <- vector(length = 3)
for (i in 1:length(branches)){
  no.sel3[i] <- length(unique(data.df$Gene[data.df$BranchTested == paste(branches[i]) 
                           & data.df$Class == "Background"]))
}

prop.test(sel3, no.sel3)
```

```{r}
prop.trend.test(sel3, no.sel3)
```

##Evolutionary Rate

For the purposes of this part of the analysis I will be using dN/dS ratio (omega) scores as a measure of evolutionary rate. The larger the score, the faster the protein product is considered to be evolving.

For this, codeML considered the alignments and tree topology without any prior designation and so there is no breakdown by origin / elaboration of sociality.

```{r}
head(data.df)
```


###Visualise.


```{r}
boxplot(dN.dS~Function, data = data.df)
```

And just to look at the statistics.

```{r}
data.df %>%
  group_by(Class) %>%
  select(dN.dS, Class) %>%
  mutate(Mean = mean(dN.dS)) %>%
  select(Class, Mean) %>%
  unique()
```

```{r}
data.df %>%
  group_by(Function) %>%
  select(dN.dS, Function) %>%
  mutate(Mean = mean(dN.dS)) %>%
  select(Function, Mean) %>%
  unique()
```


###Tests of Significance

Using Kruskalâ€“Wallis one-way analysis of variance as data is non-parametric. For example ...

```{r}
hist(data.df$dN.dS[data.df$Class == "Non-Canon"], main = "", xlab = "dN.dS")
```

Anyway.

```{r}
group_by(data.df, Function) %>%
  summarise(
    count = n(),
    mean = mean(dN.dS, na.rm = T),
    sd = sd(dN.dS, na.rm = T),
    median = median(dN.dS, na.rm = T),
    IQR = IQR(dN.dS, na.rm = T)
  )
```



```{r}
ggline(data.df, x = "Function", y = "dN.dS", 
       add = c("mean_se", "jitter"), 
       ylab = "Omega", xlab = "Gene Class")
```

And the test ...

```{r}
kruskal.test(dN.dS ~ as.factor(Function), data = data.df)
```

Ooh. There are differences.

```{r}
dunnTest(dN.dS ~ as.factor(Function), data = data.df, method = "bonferroni") 
```

```{r}
test <- dunnTest(dN.dS ~ Function, data = data.df, method = "bonferonni")
dunndf <- test$res
dunndf %>%
  filter(P.adj > 0.05)
```

```{r}
comps <- list(c("Background", "Non-Canon Immune"),
              c("Effector", "Non-Canon Immune"),
              c("Background", "Receptor"),
              c("Effector", "Receptor"),
              c("Background", "Signalling"),
              c("Effector", "Signalling"),
              c("Non-Canon Immune", "Signalling"),
              c("Receptor", "Signalling"))

ggplot(data = data.df, aes(x = Function, y = dN.dS)) +
  geom_violin() +
  stat_compare_means(comparisons = comps,
                    label = "p.signif", 
                    symnum.args = list(cutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1),
                    symbols = c("****", "***", "**", "*", "ns")),
                    method = "wilcox",
                    size = 5)
```

```{r}
TukeyHSD(aov(data = data.df,
      dN.dS ~ Function))
```

```{r}
write.table(dunndf, "output/DunnTest_DnDsbyGeneFunc.tsv",
            col.names = T, row.names = F, sep = "\t", quote = F)
```


##GO Analysis

GO analysis will be ran on canon / noncanon / random genes under selection per lineage. Go terms can then be checked for comparisons between socialities, etc.

The first step here will be making gene lists of genes under selection per each lineage, separated by class of gene (noncanon candidate / random background). There will be a file called Hym_NonCan I will also look at - these are the noncanon genes that are only found in Hymenoptera and not in other insect species considered (see previous project for details). I will also be running a GO analysis of all canon immune genes and all candidate immune genes to see if there is much overlap in terms of gene function. NB: gene lists must be in the form of their associated protein's ID. 

Once the lists are complete, I will write them as text files and save them in "input/GOI/" to be fed into GO analysis scripts (topGO). Results will be written as results files, before I make a master file of all GOterms over represented per lineage per class of gene. 

This can then be used for comparative means - Venn tables, etc.


###Gene Lists

####Canon and Noncanon (all)

These are just lists of all canon and non canon immune genes to look and see if they have much in common.

```{r}
can.imm <- read.table("ImmResources/ImmuneFunction_Nov2021.tsv", sep = "\t", header = T)
head(can.imm)

can.imm[can.imm$Gene == "Pgrp-S2",]
```

```{r}
id <- read.table("Genome_Misc/AmelHAv3.1_filtered.checked.faa.table", sep = "\t",
                 header = T)
head(id)
```

I'm having issue with some discontinued entries being in the immune list (thanks OrthoDb) so need to remove them first

```{r}
disc <- c("LOC100576380", "LOC100577249", "LOC102654182", "LOC727231")
can.imm <- can.imm[!can.imm$Gene %in% disc,]
#no protein id on nbci
noprot <- c("LOC725413")
can.imm <- can.imm[!can.imm$Gene %in% noprot,]
```


```{r}
for (i in 1:nrow(can.imm)){
  can.imm[i,3] <- paste(id$Resolved_Isoform[id$Gene == paste(can.imm[i,1])])
}
```
Write up all canon protein product list....

```{r}
dir.create("input/GOI")
can.prot <- as.data.frame(can.imm$V3)
write.table(can.prot, "input/GOI/AllCanon_ProtList.txt", col.names = F, row.names = F,
            quote = F)
```


... and candidate (noncanon)


```{r}
non.can <- read.table("ImmResources/Prelim_NonCanList2.txt", header = F)
#Remove any potential problems
#discontinued
disc <- c("LOC412892")
non.can <- non.can[!non.can[,1] %in% disc,]
#no protein id on nbci. Non.can is now a vector of gene ids
noprot <- c("LOC409174", "LOC413237", "LOC413645", "SPH42", "LOC551600", "LOC724595", "Fur1",
            "LOC727136", "Ancr-1", "LOC100577586", "LOC100577781")
non.can <- non.can[!non.can %in% noprot]
#back into dataframe
non.can <- as.data.frame(non.can)
```


```{r}
for (i in 1:nrow(non.can)){
  non.can[i,2] <- paste(id$Resolved_Isoform[id$Gene == paste(non.can[i,1])])
}
```

Write up 

```{r}
noncan.prot <- as.data.frame(non.can$V2)
write.table(noncan.prot, "input/GOI/AllNonCanon_ProtList.txt", col.names = F, row.names = F,
            quote = F)
```

###Genes under selection

I will craft a script that will go through the undersel object and drag out the genes under selection per lineage per gene class (noncan / random). Each set will be stored in a data.frame object and then written as a .txt file in the "input/GOI" directory. 


```{r} 
source("Scripts/genGeneList2.R", local = knitr::knit_global())
```

###The Analysis

I had previously produced a GOverse file to use with topGO using the script genGOverse.R. This will be read in using the topGO batch script.


runtopGO.R produces many results files. For each lineage/class combination (and the canon and noncanon input lists) there will be one table written that has all three GO term classes included.

```{r echo=T, results='hide'}
#source("Scripts/runtopGO.R", local = knitr::knit_global())
```


##CMD Considerations

So, whilst doing this project it became apparent that the branch-site test of selection has a setback - it counts all codons of multiple differences (CMDs) that may have occurred due to single multiple nucleotide mutations (MNM) as positive selection, when this may not be the case. As it assume that all nucleotide changes are individual events and does not consider MNM it overestimates the importance of these codons. They may still have become fixated thanks to positive selection, but these codons may also persist thanks to neutral fixation. And the test cannot discern between these two phenomena

With this in mind, I used the hyphy module FMM to run through all my alignments and assess if the selection analysis would have benefited from a model that took into consideration 2-hit and 3-hit simultaneous nucleotide mutations. I then parsed from the reports what codons in particular were likely to be CMD due to MNM per gene. I also pulled out the original sites under selection according to BEB. If a gene has been flagged as under selection by the BST, I compare the codons it designates as under selection with those that FMM considers likely to be due to MNM. If all codons are considered to be MNM-derived, I consider that the gene should be flagged as "uncertain", meaning that I can't say for sure if its actually under direct positive selection or not. If there are still significant codons that have not been flagged as MNM-derived, I suggest that the evidence is a little stronger than the gene is indeed under selection.

Only genes that were considered under positive selection per branch test were checked.

```{r}
filelist <- list.files(path = "input/MNM/", pattern = "*tsv")
filelist
```

```{r}
unique(data.df$SocOrigin)
```

Slightly different naming structure, which I'm going to have to take into consideration.

Will be using a function I created in the dataRead.R script, getname

```{r}
mnm.list <- lapply(filelist, function(x){
  read.table(paste("input/MNM/", x, sep =""), header = T, sep = "\t")
})

head(mnm.list[[3]])
```

```{r}
for (i in 1:length(mnm.list)){
  mnm.list[[i]]$BranchTest <- getname(filelist[i])
}

head(mnm.list[[5]])
```

"Halictid", "Nova" and "Xylo" 

```{r}
mnm.df <- bind_rows(mnm.list)

mnm.df$BranchTest[mnm.df$BranchTest == "Halictid"] <- "Lasio"
mnm.df$BranchTest[mnm.df$BranchTest == "Xylo"] <- "Ceratina"
mnm.df$BranchTest[mnm.df$BranchTest == "Nova"] <- "Dufourea"

head(mnm.df)
```

```{r}
write.table(mnm.df, "output/MNM_Entire.tsv",
            col.names = T, row.names = F, quote = T, sep = "\t")
```


I need to go through the significant dataframe by SocOrigin and paste each test result per gene ....

There's a couple of failures in the background genes I'm going to remove

```{r}
torem <- c("LOC408808", "Kr")
data.sig <- data.sig[!data.sig$Gene %in% torem,]

names(data.sig)
```


```{r}
for (i in 1:nrow(data.sig)){
  soc <- data.sig[i,5]
  gene <- data.sig[i,1]
  data.sig[i,18] <- mnm.df$X2hit[mnm.df$Gene == paste(gene) & mnm.df$BranchTest == paste(soc)]
  data.sig[i,19] <- mnm.df$X3hit[mnm.df$Gene == paste(gene) & mnm.df$BranchTest == paste(soc)]
  names(data.sig)[18:19] <- c("TwoHitCheck", "ThreeHitCheck")
}

head(data.sig)
```

Even if there is only one fail in either test the gene must be flagged as uncertain

```{r}
x <- nrow(data.sig[data.sig$TwoHitCheck == "Fail" | data.sig$ThreeHitCheck == "Fail",])
(x / nrow(data.sig))*100
```

2.64% . . . 

##GC Content

I incorporated average GC content into the master aln file I read in at the beginning but I have GC information per species that may be worth looking into 

```{r}
gc <- read.table("input/GC/gc_Content.tsv", header = T, sep = "\t")
head(gc)
```

I can't play with plots with the data in this format.

I need to loop through the species, using species name to extract columns. I can then paste the species name next to the reads. I'll make a 3column dataframe per species with gene/ GC/ and species / columns then combine at the end.

```{r}
species <- names(gc[,3:13])

spec.list <- vector(mode = "list", length = length(species))

for (i in 1:length(species)){
  one <- gc[[species[i]]]
  two <- as.data.frame(cbind(gc[,1], one))
  two$Species <- paste(species[i])
  names(two)[1:2] <- c("Gene", "GC")
  spec.list[[i]] <- two
}

gc2 <- bind_rows(spec.list)
gc2$GC <- as.numeric(gc2$GC)
tail(gc2)
```

```{r}
ggplot(data = gc2, aes(x = Species, y = GC)) +
  geom_boxplot()
```

```{r}
elaboration2 <- c("Amel", "Aflo", "Mqua")
origin2 <- c("Bimp", "Bter", "Ccal", "Emex", "Lalb")
solitary2 <- c("Dnov", "Mrot", "Hlab")

gc2$BranchTest[gc2$Species %in% elaboration2] <- "Elaboration of Sociality"
gc2$BranchTest[gc2$Species %in% origin2] <- "Origin of Sociality"
gc2$BranchTest[gc2$Species %in% solitary2] <- "Solitary"

head(gc2)
```
```{r}
ggplot(data = gc2, aes(x = Species, y = GC, fill = BranchTest)) +
  geom_boxplot()
```

##GC vs dNdS / Selection
###dNdS

Is evolutionary rate and gc content correlated? 

First, can I use parametric tests to check average GC per gene against dNdS per gene ? (I have a feeling dNdS may not be....)

GC first

```{r}
ggplot(verse, aes(x=GeneAverage)) + 
    geom_histogram(aes(y = ..density..), binwidth=.25, colour="black", fill="white") +
    stat_function(fun = dnorm, lwd = 2, col = 'red', 
            args = list(mean = mean(verse$GeneAverage), sd = sd(verse$GeneAverage)))

```
Hmm. Pretty normally distributed ....

```{r}
ggplot(verse, aes(sample = GeneAverage)) + stat_qq()
```

Kiinda. 

```{r}
work4 <- verse
work4$logGC <- log(work4$GeneAverage)

ggplot(work4, aes(x=logGC)) + 
    geom_histogram(aes(y = ..density..), binwidth=.25, colour="black", fill="white") +
    stat_function(fun = dnorm, lwd = 2, col = 'red', 
            args = list(mean = mean(work4$logGC), sd = sd(work4$logGC)))
```

Ok sweet. Now for dNdS

```{r}
ggplot(work4, aes(x=dN.dS)) + 
    geom_histogram(aes(y = ..density..), binwidth=.25, colour="black", fill="white") +
    stat_function(fun = dnorm, lwd = 2, col = 'red', 
            args = list(mean = mean(work4$dN.dS), sd = sd(work4$dN.dS)))
```

Eeek.

```{r}
work4$logOmega <- log(work4$dN.dS)

ggplot(work4, aes(x=logOmega)) + 
    geom_histogram(aes(y = ..density..), binwidth=.25, colour="black", fill="white") +
    stat_function(fun = dnorm, lwd = 2, col = 'red', 
            args = list(mean = mean(work4$logOmega), sd = sd(work4$logOmega)))

```


Better but still skewed. So maybe not parametric.

```{r}
cor.test(work4$logOmega, work4$logGC, method = "kendall")
```

```{r}
work4.non <- work4[work4$Function == "Non-Canon Immune",]

ggplot(work4, aes(x = logOmega, y = logGC)) +
  geom_point(aes(color = Function, alpha = Immune, shape = Class)) +
  scale_alpha(guide = "none") +
  stat_ellipse(data = work4[work4$Function == "Non-Canon Immune",], colour = "violet") +
  scale_color_manual(values = c("gray",
                                "#56B4E9",
                               "violet",
                               "#009E73",
                                "#F0E442"), 
                     name = "Gene Class") +
   geom_line(stat="smooth",method = "lm",
              size = .5,
              linetype ="dashed",
              alpha = 0.5) + 
        xlab("log dN/dS ratio") +
        ylab("log GC content")

```

Let's try this since I've just found

```{r}
ggplot(work4, aes(y=logGC, x=logOmega)) +
  geom_point(cex=1) +
  stat_density_2d(aes(fill = ..level..), geom = "polygon", colour="white") +
  scale_y_continuous("logGC", breaks = seq(0, 600000, by = 100000),
                     labels = str_c(seq(0, 600, by = 100), "k")) +
  theme(legend.position = "none")
```

```{r}
ggplot(work4, aes(y=logGC, x=logOmega, color = Class)) +
  geom_point(cex=1, alpha=.2) +
  geom_density_2d() +
  scale_y_continuous("logGC", breaks = seq(0, 400000, by = 100000), labels = str_c(seq(0, 400, by = 100), "k")) +
  scale_color_discrete(name = "")
```



Last little look

```{r}
mod.ogc <- lm(logOmega ~ logGC, data = work4)
summary(mod.ogc)
```


```{r}
int <- mod.ogc$coefficients["(Intercept)"]
slope <- mod.ogc$coefficients["logGC"]

plot(logOmega ~ logGC,
     data = work4,
     pch=1,
     xlab = "log dN/dS", 
     ylab = "log GC Content")
abline(int, slope,
       lty=1, lwd=2, col="blue") 
```

As evolutionary rate increases, GC content tends to slightly decrease.

Though it's interesting to note that non-canon genes and receptor genes are in the uppermost of both higher GC content and higher omega value. 

##SessionInfo
```{r}
sesh <- sessionInfo()
#writeLines(capture.output(sessionInfo()), "sessionInfo.txt")
```

```{r}
sesh
```